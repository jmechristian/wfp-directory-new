import fs from 'fs';
import path from 'path';

function parseDotenv(contents) {
  const out = {};
  const lines = contents.split(/\r?\n/);
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    const eq = trimmed.indexOf('=');
    if (eq === -1) continue;
    const key = trimmed.slice(0, eq).trim();
    let val = trimmed.slice(eq + 1).trim();
    // remove surrounding quotes
    if (
      (val.startsWith('"') && val.endsWith('"')) ||
      (val.startsWith("'") && val.endsWith("'"))
    ) {
      val = val.slice(1, -1);
    }
    out[key] = val;
  }
  return out;
}

function loadEnvFromFiles(projectRoot) {
  // Match Next.js precedence roughly (local overrides general)
  const candidates = [
    '.env.local',
    '.env.development.local',
    '.env.production.local',
    '.env',
  ];

  const merged = {};
  for (const file of candidates) {
    const p = path.join(projectRoot, file);
    if (!fs.existsSync(p)) continue;
    try {
      const contents = fs.readFileSync(p, 'utf8');
      Object.assign(merged, parseDotenv(contents));
    } catch (e) {
      // Don't fail generation if the file exists but isn't readable in some environments.
      // We'll still pick up values from process.env (e.g., Vercel Environment Variables).
      // eslint-disable-next-line no-console
      console.warn(`[generate-aws-exports] Skipping unreadable ${file}: ${e?.message || e}`);
    }
  }
  return merged;
}

function requireVal(env, key) {
  const v = env[key];
  if (!v) throw new Error(`Missing required env var for aws-exports generation: ${key}`);
  return v;
}

function main() {
  const projectRoot = process.cwd();
  const fileEnv = loadEnvFromFiles(projectRoot);
  const env = { ...fileEnv, ...process.env };

  const region =
    env.NEXT_PUBLIC_AWS_PROJECT_REGION ||
    env.NEXT_PUBLIC_AWS_APPSYNC_REGION ||
    env.NEXT_PUBLIC_AWS_REGION;

  if (!region) {
    throw new Error(
      'Missing region. Set NEXT_PUBLIC_AWS_PROJECT_REGION (recommended) in .env.local or environment.'
    );
  }

  const awsExports = {
    aws_project_region: region,
    aws_appsync_graphqlEndpoint: requireVal(env, 'NEXT_PUBLIC_AWS_APPSYNC_GRAPHQL_ENDPOINT'),
    aws_appsync_region: region,
    aws_appsync_authenticationType:
      env.NEXT_PUBLIC_AWS_APPSYNC_AUTHENTICATION_TYPE || 'API_KEY',
    aws_appsync_apiKey: requireVal(env, 'NEXT_PUBLIC_AWS_APPSYNC_API_KEY'),
    aws_cognito_region: region,
    aws_user_pools_id: requireVal(env, 'NEXT_PUBLIC_AWS_USER_POOLS_ID'),
    aws_user_pools_web_client_id: requireVal(env, 'NEXT_PUBLIC_AWS_USER_POOLS_WEB_CLIENT_ID'),
    oauth: {},
  };

  const outPath = path.join(projectRoot, 'src', 'aws-exports.js');
  const js = `/* eslint-disable */
// WARNING: DO NOT EDIT. This file is generated by scripts/generate-aws-exports.mjs

const awsmobile = ${JSON.stringify(awsExports, null, 2)};

export default awsmobile;
`;

  fs.writeFileSync(outPath, js, 'utf8');
  // eslint-disable-next-line no-console
  console.log(`[generate-aws-exports] Wrote ${outPath}`);
}

main();


